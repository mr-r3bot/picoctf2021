## Code analysis

#### Reverse engineer:
```c
int main(void)

{
  long in_FS_OFFSET;
  undefined value_input;
  int address_input;
  int i;
  int64_t *null_ptr;
  char *ptr_a;
  FILE *flag_fd;
  undefined8 *local_88;
  void *void_ptr;
  undefined8 this_is_str;
  undefined8 a_random_str;
  undefined8 strings_str;
  undefined local_60;
  char flag_buffer [72];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  setbuf(stdout,(char *)0x0);
  flag_fd = fopen("flag.txt","r");
  fgets(flag_buffer,0x40,flag_fd);
  this_is_str = 2338328219631577204;
  a_random_str = 7885631897793077345;
  strings_str = 3343762647516738336;
  local_60 = 0;
  null_ptr = (int64_t *)0x0;
  for (i = 0; i < 7; i = i + 1) {
    ptr_a = (char *)malloc(0x80);
    if (null_ptr == (int64_t *)0x0) {
      null_ptr = (int64_t *)ptr_a;
    }
    *(int64_t *)ptr_a = 8319381555649605443;
    *(int64_t *)((long)ptr_a + 8) = 7359007639828242465;
    *(int64_t *)((long)ptr_a + 0x10) = 2322295453215318380;
                    /* Congrats ! Your flag is:  */
    *(undefined *)((long)ptr_a + 0x18) = 0;
    strcat(ptr_a,flag_buffer);
  }
  local_88 = (undefined8 *)malloc(0x80);
  *local_88 = 6061881903935549267;
  local_88[1] = 2841330972353587560;
  local_88[2] = 8728099688704122996;
                    /* Sorry, this won't help you: */
  *(undefined4 *)(local_88 + 3) = 540702063;
  *(undefined *)((long)local_88 + 0x1c) = 0;
  strcat((char *)local_88,(char *)&this_is_str);
  free(ptr_a);
  free(local_88);
  address_input = 0;
  value_input = 0;
  puts("You may edit one byte in the program.");
  printf("Address: ");
  __isoc99_scanf("%d",&address_input);
  printf("Value: ");
  __isoc99_scanf(" %c",&value_input);
  *(undefined *)((long)address_input + (long)null_ptr) = value_input;
  void_ptr = malloc(0x80);
  puts((char *)((long)void_ptr + 0x10));
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```

#### Code analysis:

- The source code open the `flag.txt` file and then read it to buffer. Allocate buffer
- Allocates seven buffers, copies a string into them ("Congrats! Your flag is:"), concatenates the flag to each buffer, saves a pointer to the first buffer in `null_ptr` and a pointer to the seventh buffer in `ptr_a`
- Allocates another buffer, copies a string into it ("Sorry! This won't help you: this is a random string."), and saves a pointer to it in `local_88` buffer. I also appends another string to it.

- Free `local_88` and `ptr_a`'s heap chunks
- Asks the user to change the value of one byte, relative to the first buffer
- Allocates a new buffer and prints its contents (starting from offset 16)

#### Fix linker and run binary

Using `pwninit` to fetch linker library and patch binary

<img width="420" alt="image" src="https://user-images.githubusercontent.com/37280106/130640586-a0670379-7020-422b-af2d-ea7c50d2c561.png">

Add random values to see the binary output:

```
──(kali㉿kali)-[~/picoctf-2021]
└─$ ./heapedit
You may edit one byte in the program.
Address: 1
Value: 1
t help you: this is a random string.
```

We see the "t help you: this is a random string." string output. If you notice, the output is a part of `local_88` char buffer, why do we still see data of `local_88` buffer even when the program called `free(local_88)` ? 

One of the thing about `free(*ptr)` is that it does not zero out the memory.
When `free` is called, it convert the pointer back to chunk by subtracting the size of chunk metadata
The freed chunk are stored in corresponding “free bins” that operate as linked list. This requires each free chunk store pointers to other chunks.
**If the chunked is fit into a tcache bin, it will be stored there**

So now, we can guess what happened when we call `void_ptr = malloc(0x80);`. The freed chunk size is `0x80` is the size of new malloc is also `0x80`.

When the memory allocation happen, if the size of memory allocated corresponds to tcache bin and there is tcache chunk available, it will return that immediately.

